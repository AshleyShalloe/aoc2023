<!DOCTYPE html>
<html lang="en">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="../res/main.css">
    <script type="text/javascript" src="../res/main.js"></script>
    <title>Advent of Code // Day 17</title>
    <link rel="icon" href="../favicon.png" />
    <style>
        #theGrid, #theGrid td, #theGrid tr{
            border: 1px solid white;
            border-collapse: collapse;
        }
        #theGrid{
            margin: 30px;
        }
        #theGrid td.theWay{
            background: yellow !important;
        }
        #theGrid td.visited{
            background: green !important;
        }
        #theGrid td.checked{
            background: purple;
        }
        #theGrid td{
            width: 2em;
            height: 2em;
            font-size: 0.7em;
        }
    </style>
</head>

<body>

    <h2>1</h2>
    <input id="fancyAnswer1" disabled></input>
    <h2>2</h2>
    <input id="fancyAnswer2" disabled></input>

</body>
<script>
    'use strict'

    const testInput = `2413432311323
3215453535623
3255245654254
3446585845452
4546657867536
1438598798454
4457876987766
3637877979653
4654967986887
4564679986453
1224686865563
2546548887735
4322674655533`

    const puzzleInput = ``

    async function go(){
        // https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
        var unvisitedNodes = new Set()
        var tentativeDistancesObj = {}
        var currentNode = "0,0"
        var currentStraightLineDistanceTravelled = 0
        var destinationNode = `${inputWidth-1},${inputHeight-1}`
        var nodeParentsObj = {}

        theGrid.rows[0].cells[0].classList.add("visited")
        
        // init univisitedNodes
        for (var i=0; i<inputHeight; i++){
            for (var j=0; j<inputWidth; j++){
                unvisitedNodes.add([j,i].toString())
            }
        }

        // init tentative distances
        unvisitedNodes.forEach(x => tentativeDistancesObj[x] = Infinity)
        tentativeDistancesObj["0,0"] = 0

        while (true){
            // consider unvisited neighbours of current node
            // calculate their tentative distances
            // var tempNeighbours = [...generateNeighbourSet(currentNode).intersection(unvisitedNodes)]
            var tempNeighbours = [...setIntersection(generateNeighbourSet(currentNode, nodeParentsObj), unvisitedNodes)]
            var bannedCoords = getBannedCoords(currentNode, nodeParentsObj)
            
            for (var i=0; i<tempNeighbours.length; i++){
                var [tempCol, tempRow] = tempNeighbours[i].split(",").map(x => parseInt(x))
                var currentlyAssignedDistance = parsedInput[tempRow][tempCol]
                var tentativeDistance = tentativeDistancesObj[currentNode] + currentlyAssignedDistance

                if (tentativeDistance < tentativeDistancesObj[tempNeighbours[i]]){
                    tentativeDistancesObj[[tempCol, tempRow].toString()] = tentativeDistance
                    nodeParentsObj[[tempCol, tempRow].toString()] = currentNode
                    theGrid.rows[tempRow].cells[tempCol].innerHTML = tentativeDistance
                }

                theGrid.rows[tempRow].cells[tempCol].classList.add("checked")
                
                await sleep(10)
            }

            // mark current node as visited by
            // removing from univisited set
            unvisitedNodes.delete(currentNode)

            // select unvisited node with smallest tentative distance
            currentNode = getUnvisitedNodeWithSmallestTentativeDistance(unvisitedNodes, tentativeDistancesObj, bannedCoords)
            theGrid.rows[tempRow].cells[tempCol].classList.add("visited")
            console.log(currentNode)
            if (currentNode == destinationNode){
                console.log("done, apparently")
                highlightParentSteps(nodeParentsObj)
                return
            }
        }
    }

    function highlightParentSteps(inputObj){
        var destinationNode = [inputWidth-1, inputHeight-1].toString()
        var originNode = [0,0].toString()
        var currentNode = destinationNode

        while (currentNode != originNode){
            var [currentCol, currentRow] = currentNode.split(",").map(x => parseInt(x))
            var targetElm =  theGrid.rows[currentRow].cells[currentCol]
            targetElm.classList.remove("visited", "checked")
            targetElm.classList.add("theWay")

            currentNode = inputObj[currentNode]
        }

        var [currentCol, currentRow] = [0,0]
            var targetElm =  theGrid.rows[currentRow].cells[currentCol]
            targetElm.classList.remove("visited", "checked")
            targetElm.classList.add("theWay")
    }

    const sleep = ms => new Promise(r => setTimeout(r, ms));

    function setIntersection(setA, setB){
        var intersection = new Set()
        var setAArray = [...setA]
        
        for (var i=0; i<setAArray.length; i++){
            if (setB.has(setAArray[i])){
                intersection.add(setAArray[i])
            }
        }

        return intersection
    }

    function getUnvisitedNodeWithSmallestTentativeDistance(unvisitedSet, tentativeObj, bannedCoords){
        var tempList = [...unvisitedSet]
        if (bannedCoords){
            tempList = tempList.filter(x => x != bannedCoords)
        }
        var smallestTDSeen = Infinity
        var returnNode = tempList[0] // init

        for (var i=0; i<tempList.length; i++){
            var tempNode = tempList[i]
            var td = tentativeObj[tempNode]
            
            if (td < smallestTDSeen){
                smallestTDSeen = td
                returnNode = tempNode
            }
        }

        return returnNode
    }

    function getLastThreeNodes(inputCoordsString, parentNodesObj){
        var returnArray = []
        var tempCoords = inputCoordsString
        while (returnArray.length < 3){
            try{
                tempCoords = parentNodesObj[tempCoords]
                returnArray.push(tempCoords)
            }
            catch{
                continue
            }
        }
        return returnArray.filter(x => x)
    }

    function getBannedDirection(inputCoordsString, parentNodesObj){
        var col = parseInt(inputCoordsString.split(",")[0])
        var row = parseInt(inputCoordsString.split(",")[1])
        var last3Nodes = getLastThreeNodes(inputCoordsString, parentNodesObj)
        var sameRow = (new Set(last3Nodes.map(x => x.split(",")[1]))).size == 1
        var sameCol = (new Set(last3Nodes.map(x => x.split(",")[0]))).size == 1
        var sameRowDirection
        var sameColDirection
        var bannedDirection
        if (last3Nodes.length < 3){
            sameRow = false
            sameCol = false
        }
        if (sameRow){
            sameRowDirection = parseInt(last3Nodes[0].split(",")[0]) - col // if negative, ban west else east
            bannedDirection = sameRowDirection < 0 ? "west" : "east"
        }
        if (sameCol){
            sameColDirection = parseInt(last3Nodes[0].split(",")[1]) - row // if negative, ban north else south
            bannedDirection = sameColDirection < 0 ? "north" : "south"
        }

        return bannedDirection
    }

    function getBannedCoords(inputCoordsString, parentNodesObj){
        var bannedDirection = getBannedDirection(inputCoordsString, parentNodesObj)
        var col = parseInt(inputCoordsString.split(",")[0])
        var row = parseInt(inputCoordsString.split(",")[1])
        if (bannedDirection == "west"){
            return [col+1,row].toString()
        }
        if (bannedDirection == "east"){
            return [col-1,row].toString()
        }
        if (bannedDirection == "south"){
            return [col,row-1].toString()
        }
        if (bannedDirection == "north"){
            return [col,row+1].toString()
        }
    }

    function generateNeighbourSet(inputCoordsString, parentNodesObj){
        var col = parseInt(inputCoordsString.split(",")[0])
        var row = parseInt(inputCoordsString.split(",")[1])
        var returnSet = new Set()
        var bannedCoords = getBannedCoords(inputCoordsString, parentNodesObj)

        // north
        if (row > 0){
            returnSet.add([col, row-1].toString())
        }

        // south
        if (row < (inputHeight - 1)){
            returnSet.add([col, row+1].toString())
        }

        // east
        if (col < (inputWidth - 1)){
            returnSet.add([col+1, row].toString())
        }

        // west
        if (col > 0){
            returnSet.add([col=1, row].toString())
        }

        returnSet = new Set([...returnSet].filter(x => x != bannedCoords))

        return returnSet
    }

    function initTable(){
        var tableHTML = ""
        for (var i=0; i<inputHeight; i++){
            tableHTML += "<tr>" + parsedInput[i].map(x => `<td>${x}</td>`).join("") + "</tr>"
        }
        
        var tableElm = document.createElement("table")
        tableElm.id = "theGrid"
        tableElm.innerHTML = tableHTML
        document.body.appendChild(tableElm)

        theGrid = document.getElementById("theGrid")
    }

    function parseInput(inputString) {
        return inputString.split("\n").map(x => x.split("").map(y => parseInt(y)))
    }

    function solvePuzzle() {
        return 0
    }


    function solvePuzzlePt2() {
        return 0
    }


    function init() {
        initTable()
        document.getElementById("fancyAnswer1").value = solvePuzzle().toString()
        document.getElementById("fancyAnswer2").value = solvePuzzlePt2().toString()
    }

    // globals
    const testing = true
    const parsedInput = testing ? parseInput(testInput) : parseInput(puzzleInput)
    var inputWidth = parsedInput[0].length
    var inputHeight = parsedInput.length
    var theGrid

    init();
</script>

</html>